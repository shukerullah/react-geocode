{"version":3,"file":"index.es.js","sources":["../src/index.ts"],"sourcesContent":["/**\n * Enum defining possible request types for geocoding.\n */\nexport enum RequestType {\n  ADDRESS = \"address\", // Geocoding by address\n  LATLNG = \"latlng\", // Geocoding by latitude and longitude\n  PLACE_ID = \"place_id\", // Geocoding by place ID\n}\n\n/**\n * Enum defining possible output formats for geocoding.\n */\nexport enum OutputFormat {\n  XML = \"xml\", // Output format XML\n  JSON = \"json\", // Output format JSON\n}\n\n/**\n * The URL of the Google Geocoding API.\n */\nconst GOOGLE_GEOCODE_API = \"https://maps.googleapis.com/maps/api/geocode\";\n\n/**\n * Options that can be passed to the geocoding requests.\n */\nexport interface GeocodeOptions {\n  key?: string; // API key for the Google Maps Geocoding API.\n  language?: string; // Language code for the response.\n  region?: string; // Region code for the response.\n  components?: string; // Component filtering for the response.\n  bounds?: string; // Bounding box for the response.\n  result_type?: string; // Result type filtering for the response.\n  location_type?: string; // Location type filtering for the response.\n  outputFormat: OutputFormat; // Desired output format (either XML or JSON)\n  enable_address_descriptor?: boolean; // Whether to include an address descriptor in the reverse geocoding response.\n}\n\n/**\n * Response object from the geocoding API.\n */\ninterface GeocodeResponse {\n  status: string;\n  results: GeocodeResult[];\n  address_descriptor?: AddressDescriptor;\n  plus_code?: PlusCode;\n  error_message?: string;\n}\n\n/**\n * The query parameters for geocoding requests.\n */\ninterface GeocodeQueryParams extends GeocodeOptions {\n  place_id?: string; // The plce id to geocode\n  address?: string; // The address to geocode\n  latlng?: string; // The latitude/longitude of the location to geocode\n}\n\n/**\n * Default options for the geocoding requests.\n */\nlet defaultOptions: GeocodeOptions = {\n  outputFormat: OutputFormat.JSON,\n};\n\n/**\n * Performs a geocoding request to the Google Geocoding API.\n * @function geocodeRequest\n * @async\n * @param {GeocodeQueryParams} queryParams - The query parameters for the geocoding request.\n * @returns {Promise<GeocodeResponse>} - A promise that resolves with the geocoding response object.\n * @throws {Error} - Throws an error if the geocoding request fails.\n */\nasync function geocodeRequest(\n  queryParams: GeocodeQueryParams,\n): Promise<GeocodeResponse> {\n  const { outputFormat, ...restParams } = queryParams;\n  const queryString = new URLSearchParams(\n    restParams as Record<string, string>,\n  ).toString();\n  const url = `${GOOGLE_GEOCODE_API}/${outputFormat}?${queryString}`;\n  try {\n    const response = await fetch(url);\n    const json = await response.json();\n    const { status, error_message } = json;\n\n    if (status === \"OK\") {\n      return json;\n    }\n\n    throw new Error(\n      `Geocoding failed: ${error_message}. Server returned status code ${status}.`,\n    );\n  } catch (error: unknown) {\n    if (error instanceof Error) {\n      throw new Error(`Geocoding request failed: ${error.message}`);\n    }\n    throw new Error(`Geocoding request failed with unknown error: ${error}`);\n  }\n}\n\n/**\n * Sets default options for geocoding requests.\n *\n * @param options - The default options to set.\n */\nexport function setDefaults(options: GeocodeOptions): void {\n  defaultOptions = {\n    ...defaultOptions,\n    ...options,\n  };\n}\n\n/**\n * Sets the API key to use for geocoding requests.\n *\n * @param key - The API key to set.\n */\nexport function setKey(key: string): void {\n  defaultOptions.key = key;\n}\n\n/**\n * Sets the language to use for geocoding requests.\n *\n * @param language - The language to set.\n */\nexport function setLanguage(language: string): void {\n  defaultOptions.language = language;\n}\n\n/**\n * Sets the region code to use for geocoding requests.\n *\n * @param region - The region code to set.\n */\nexport function setRegion(region: string): void {\n  defaultOptions.region = region;\n}\n\n/**\n * Sets the component filter to use for geocoding requests.\n *\n * @param components - The component filter to set.\n */\nexport function setComponents(components: string): void {\n  defaultOptions.components = components;\n}\n\n/**\n * Sets the bounding box to use for geocoding requests.\n *\n * @param bounds - The bounding box to set.\n */\nexport function setBounds(bounds: string): void {\n  defaultOptions.bounds = bounds;\n}\n\n/**\n * Sets the result type filter to use for geocoding requests.\n * One or more address types to return, separated by a pipe (|).\n * Possible values are \"street_address\", \"route\", \"intersection\", \"political\", \"country\",\n * \"administrative_area_level_1\", \"administrative_area_level_2\", \"administrative_area_level_3\",\n * \"administrative_area_level_4\", \"administrative_area_level_5\", \"colloquial_area\", \"locality\",\n * \"ward\", \"sublocality\", \"neighborhood\", \"premise\", \"subpremise\", \"postal_code\", \"natural_feature\",\n * \"airport\", \"park\", \"point_of_interest\", and \"postal_code_prefix\".\n *\n * @param resultType - The result type to set.\n */\nexport function setResultType(resultType: string): void {\n  defaultOptions.result_type = resultType;\n}\n\n/**\n * Sets the location type filter to use for geocoding requests.\n * One or more location types to return. Possible values are \"ROOFTOP\",\n * \"RANGE_INTERPOLATED\", \"GEOMETRIC_CENTER\", \"APPROXIMATE\".\n *\n * @param locationType - The location type to set.\n */\nexport function setLocationType(locationType: string): void {\n  defaultOptions.location_type = locationType;\n}\n\n/**\n * Sets the desired output format for geocoding requests. The format can be either XML or JSON.\n *\n * @param outputFormat - The desired output format (either OutputFormat.XML or OutputFormat.JSON).\n */\nexport function setOutputFormat(outputFormat: OutputFormat): void {\n  defaultOptions.outputFormat = outputFormat;\n}\n\n/**\n * Sets whether to include an address descriptor in the reverse geocoding response.\n *\n * @param enableAddressDescriptor - A boolean parameter indicating whether to include the address descriptor.\n */\nexport function enableAddressDescriptor(\n  enableAddressDescriptor: boolean,\n): void {\n  defaultOptions.enable_address_descriptor = enableAddressDescriptor;\n}\n\n/**\n * Sends a geocoding request to the Google Maps Geocoding API for a given address and returns the response.\n * @function geocode\n * @async\n * @param {RequestType} requestType - Identifier to specify the type of request (place_id, address, or latlng).\n * @param {string} value - The value to be used for geocoding (address, place_id, or latlng).\n * @param {GeocodeOptions} [options={}] - Additional options for the geocoding request.\n * @returns {Promise<GeocodeResponse>} - A promise that resolves with the geocoding response object.\n * @throws {Error} - Throws an error if the address is invalid or the geocoding request fails.\n */\nexport function geocode(\n  requestType: RequestType | string,\n  value: string,\n  options?: GeocodeOptions,\n): Promise<any> {\n  if (typeof requestType !== \"string\" || typeof value !== \"string\") {\n    throw new Error(\n      `Both requestType and value are required and must be of type string. \n       requestType: ${typeof requestType}, value: ${typeof value}`,\n    );\n  }\n\n  const queryParams: GeocodeQueryParams = {\n    ...defaultOptions,\n    ...options,\n    [requestType]: value,\n  };\n  return geocodeRequest(queryParams);\n}\n\n/**\n * @deprecated Use `geocode` instead.\n * Usage: geocode(\"address\", \"Washington\", *options)\n */\nexport function fromAddress(\n  address: string,\n  key?: string,\n  language?: string,\n  region?: string,\n) {\n  const options: GeocodeOptions = {\n    outputFormat: OutputFormat.JSON,\n  };\n  if (key) {\n    options.key = key;\n  }\n  if (language) {\n    options.language = language;\n  }\n  if (region) {\n    options.region = region;\n  }\n  return geocode(RequestType.ADDRESS, address, options);\n}\n\n/**\n * @deprecated use `geocode` instead\n * Usage: geocode(\"place_id\", \"ChIJd8BlQ2BZwokRAFUEcm_qrcA\", *options)\n */\nexport function fromPlaceId(\n  placeId: string,\n  key?: string,\n  language?: string,\n  region?: string,\n) {\n  const options: GeocodeOptions = {\n    outputFormat: OutputFormat.JSON,\n  };\n  if (key) {\n    options.key = key;\n  }\n  if (language) {\n    options.language = language;\n  }\n  if (region) {\n    options.region = region;\n  }\n  return geocode(RequestType.PLACE_ID, placeId, options);\n}\n\n/**\n * @deprecated use `geocode` instead\n * Usage: geocode(\"latlng\", \"40.714224,-73.961452\", *options)\n */\nexport function fromLatLng(\n  lat: number,\n  lng: number,\n  key?: string,\n  language?: string,\n  region?: string,\n  location_type?: string,\n) {\n  const options: GeocodeOptions = {\n    outputFormat: OutputFormat.JSON,\n  };\n  if (key) {\n    options.key = key;\n  }\n  if (language) {\n    options.language = language;\n  }\n  if (region) {\n    options.region = region;\n  }\n  if (location_type) {\n    options.location_type = location_type;\n  }\n  return geocode(RequestType.LATLNG, `${lat},${lng}`, options);\n}\n\ninterface GeocodeResult {\n  address_components: AddressComponent[];\n  formatted_address: string;\n  geometry: Geometry;\n  place_id: string;\n  plus_code: PlusCode;\n  types: string[];\n}\n\ninterface AddressComponent {\n  long_name: string;\n  short_name: string;\n  types: string[];\n}\n\ninterface Geometry {\n  location: {\n    lat: number;\n    lng: number;\n  };\n  location_type: string;\n  viewport: {\n    lat: number;\n    lng: number;\n  };\n  southwest: {\n    lat: number;\n    lng: number;\n  };\n}\n\ninterface AddressDescriptor {\n  area: AreaDescriptor[];\n  landmarks: Landmark[];\n}\n\ninterface AreaDescriptor {\n  containment: string;\n  display_name: {\n    language_code: string;\n    text: string;\n  };\n  place_id: string;\n}\n\ninterface Landmark {\n  display_name: {\n    language_code: string;\n    text: string;\n  };\n  straight_line_distance_meters: number;\n  place_id: string;\n  travel_distance_meters: number;\n  spatial_relationship: string;\n  types: string[];\n}\n\ninterface PlusCode {\n  compound_code: string;\n  global_code: string;\n}\n"],"names":["RequestType","OutputFormat","GOOGLE_GEOCODE_API","defaultOptions","geocodeRequest","queryParams","outputFormat","restParams","queryString","url","json","status","error_message","error","setDefaults","options","setKey","key","setLanguage","language","setRegion","region","setComponents","components","setBounds","bounds","setResultType","resultType","setLocationType","locationType","setOutputFormat","enableAddressDescriptor","geocode","requestType","value","fromAddress","address","fromPlaceId","placeId","fromLatLng","lat","lng","location_type"],"mappings":"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"}